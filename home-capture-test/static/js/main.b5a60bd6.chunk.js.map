{"version":3,"sources":["services/ImageFinder.js","App.js","serviceWorker.js","index.js"],"names":["accessKeyKey","secretKeyKey","Image","s3Metadata","data","Object","classCallCheck","this","metadata","lastModified","LastModified","size","Size","name","Key","concat","ImageFinder","bucket","region","accessKey","secretKey","params","URLSearchParams","window","location","search","Storage","get","localStorage","setItem","getItem","creds","AWS","Credentials","config","update","credentials","S3","metadataCallback","imageCallback","date","moment","utc","folderPrefix","format","getObjects","prefix","continuationToken","_this","s3Params","Bucket","Prefix","ContinuationToken","listObjectsV2","promise","then","notDoneLoading","IsTruncated","NextContinuationToken","metadatas","Contents","forEach","getObject","callback","object","reader","FileReader","onload","e","base64EncodedData","target","result","image","readAsDataURL","Blob","Body","App","props","possibleConstructorReturn","getPrototypeOf","call","returnedMetadata","done","state","setState","metadataLoaded","_this$state","images","preStateImages","push","accumulatedBufferImages","length","totalAccumulatedImages","totalImageCount","sort","imageSortFn","imageFinder","loadedImageCount","a","b","getImages","_this$state2","loadingText","imgs","map","react_default","createElement","className","key","src","alt","toString","Component","Boolean","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.b5a60bd6.chunk.js","sourcesContent":["import AWS from 'aws-sdk'\nimport moment from 'moment'\n\nconst accessKeyKey = 'awsAccessKey'\nconst secretKeyKey = 'awsSecretKey'\n\nclass Image {\n    constructor(s3Metadata, data) {\n        const metadata = s3Metadata\n        this.lastModified = metadata.LastModified\n        this.size = metadata.Size\n        this.name = metadata.Key\n        this.data = data\n    }\n\n    toString() {\n        return `name: ${this.name}, size: ${this.size}, lastModified: ${this.lastModified}`\n    }\n}\n\nexport default class ImageFinder {\n\n    constructor(bucket, region) {\n        //find credentials or fail\n        this.bucket = bucket\n        this.region = region\n        const params = new URLSearchParams(window.location.search);\n    \n        let accessKey, secretKey\n    \n        // does storage exist?\n        if (typeof(Storage) !== \"undefined\") {\n    \n          // check for query params then store\n          if (params.get(accessKeyKey) && params.get(secretKeyKey)) {\n            accessKey = params.get(accessKeyKey)\n            secretKey = params.get(secretKeyKey)\n            localStorage.setItem(accessKeyKey, accessKey)\n            localStorage.setItem(secretKeyKey, secretKey)\n    \n          // check for local storage keys\n          } else if (localStorage.getItem(accessKeyKey) && localStorage.getItem(secretKeyKey)) {\n            accessKey = localStorage.getItem(accessKeyKey)\n            secretKey = localStorage.getItem(secretKeyKey)\n          } else {\n            throw \"No credentials available\"\n          }\n        } else {\n          throw \"No storage available. Are you from 1996? AWS doesn't exist yet anyway.\"\n        }\n    \n        const creds = new AWS.Credentials(accessKey, secretKey)\n    \n        AWS.config.update(\n          {\n            credentials: creds,\n            region: region\n          }\n        )\n    \n        this.S3 = new AWS.S3()\n    }\n\n    // Assumes images are prefixed with simple zero-padded\n    // date -> eg. 2018-04-16\n    // Returns S3 objects\n    getImages(metadataCallback, imageCallback) {\n        const params = new URLSearchParams(window.location.search);\n        let date = moment.utc() // now\n        // Can pass date to URL if desired\n        if (params.get('date')) {\n            date = moment(params.get('date'))\n        }\n        const folderPrefix = date.format('YYYY-MM-DD')\n \n        this.getObjects(metadataCallback, imageCallback, folderPrefix)\n    }\n\n    getObjects(metadataCallback, imageCallback, prefix, continuationToken) {\n        const s3Params = {Bucket: this.bucket, Prefix: prefix}\n\n        if (continuationToken) {\n            s3Params.ContinuationToken = continuationToken\n        }\n\n        this.S3.listObjectsV2(s3Params).promise().then((data) => {\n            const notDoneLoading = data.IsTruncated && data.NextContinuationToken\n            if(notDoneLoading) {\n                this.getObjects(metadataCallback, imageCallback, prefix, data.NextContinuationToken)\n            }\n            const metadatas = data.Contents //.splice(0,5)\n            metadataCallback(metadatas, !notDoneLoading)\n            // const metadatas = data.Contents\n            metadatas.forEach((metadata) => {\n                this.getObject(imageCallback, metadata)\n            })\n        })\n    }\n\n    getObject(callback, metadata) {\n        this.S3.getObject({Bucket: this.bucket, Key: metadata.Key}).promise().then((object) => {\n            var reader = new FileReader()\n            reader.onload = (function(self) {\n                return function(e) {\n                    const base64EncodedData = e.target.result;\n                    const image = new Image(metadata, base64EncodedData)\n                    callback(image)\n                }\n            })(this);\n            reader.readAsDataURL(new Blob([object.Body]));\n        });\n    }\n}","import React, { Component } from 'react'\nimport './App.css'\nimport ImageFinder from './services/ImageFinder'\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.imageFinder = new ImageFinder('home-motion-capture', 'us-west-2')\n    this.preStateImages = []\n    this.state = {images: [], metadata: [], metadataLoaded: false, loadedImageCount: 0}\n  }\n\n  metadataCallback = (returnedMetadata, done) => {\n    let { metadata } = this.state;\n    metadata = metadata.concat(returnedMetadata)\n    this.setState({metadata: metadata, metadataLoaded: done})\n  }\n\n  imageCallback = (image) => {\n    let { images, metadata } = this.state;\n    this.preStateImages.push(image)\n    const accumulatedBufferImages = this.preStateImages.length\n    const totalAccumulatedImages = accumulatedBufferImages + images.length\n    const totalImageCount = metadata.length\n    if (accumulatedBufferImages === 100 || totalAccumulatedImages === totalImageCount) {\n      images = images.concat(this.preStateImages).sort(this.imageSortFn)\n\n      this.setState({images: images})\n      this.preStateImages = []\n    }\n  }\n\n  imageSortFn(a, b) {\n    return b.lastModified - a.lastModified\n  }\n\n  componentDidMount() {\n    this.imageFinder.getImages(this.metadataCallback, this.imageCallback)\n  }\n\n  render() {\n    const { images, metadataLoaded, metadata } = this.state;\n    let loadingText = null\n    \n    if (metadata.length > 0) {\n      if (images.length < metadata.length) {\n        if (metadataLoaded) {\n          loadingText = `Fetching ${metadata.length} images`\n        } else {\n          loadingText = `Fetching at least ${metadata.length} images`\n        }\n      }\n    } else {\n      loadingText = \"Fetching metadata\"\n    }\n\n    const imgs = images.map((image) => {\n      return (\n        <span className=\"image\" key={image.name}>\n          <img src={image.data} alt={image.toString()}></img>\n        </span>\n      )\n    })\n\n    return (\n      <div className=\"App\">\n        <div>{loadingText}</div>\n        {imgs}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}